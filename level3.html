<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lvl 3 In Progress</title>
</head>
<style>
    .node{
        fill: #acc;
        stroke: #fff;
        stroke-width:2px;
    }
    .link{
        stroke: #111;
        stroke-width: 2px;
    }

</style>
<body>

<canvas id="network" width="500" height="500"></canvas>

<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
/* global d3 */

//TODO: export json object then import it by d3

var canvas = d3.select("#network"),
  width = canvas.attr("width"),
  height = canvas.attr("height"),
  ctx = canvas.node().getContext("2d"),
  r = 8,
  color = d3.scaleOrdinal(d3.schemeCategory30);
  


d3.json("https://raw.githubusercontent.com/HKUST-VISLab/coding-challenge/master/HKUST_coauthor_graph.json", function (err, graph) {
  if (err) throw err;

  //filter out the subgraph nodes and links
  var newNodes = graph.nodes.filter(function(i,n){
    return i.dept ==='CSE';
  });
  var newEdges = graph.edges.filter(function(i,n){
    var sourceInNodes = 0;
    var targetInNodes = 0;
    //console.log(i);
    newNodes.forEach(function(n){
      //console.log(n.id)
      if(n.id == i.source){
        sourceInNodes = 1;
      }
      else if(n.id == i.target){
        targetInNodes = 1;
      } 
    });
    //console.log(sourceInNodes);
    return (sourceInNodes==1) && (targetInNodes==1);
  })
  
  var simulation = d3.forceSimulation()
    .force("x", d3.forceX(width/2))
    .force("y", d3.forceY(height/2))
    //.force("collide", d3.forceCollide(r+21))
    .force("charge", d3.forceManyBody()
    .strength(-20))
    .force("link", d3.forceLink()
      .id(function (d) { return d.id; }).distance(100));//here to change the distance based on the number of publications tog

  simulation.nodes(newNodes);
  simulation.force("link")
   .links(newEdges);
   simulation.force("link")
  simulation.on("tick", update);

  canvas
      .call(d3.drag()
          .container(canvas.node())
          .subject(dragsubject)
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

  function update() {
    ctx.clearRect(0, 0, width, height);
    ctx.beginPath();
    ctx.globalAlpha = 0.1;
    ctx.strokeStyle = "#aaa";
    newEdges.forEach(drawLink);
    ctx.stroke();


    ctx.globalAlpha = 1.0;
    newNodes.forEach(drawNode);
  }

  function dragsubject() {
    return simulation.find(d3.event.x, d3.event.y);
  }

});

function dragstarted() {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d3.event.subject.fx = d3.event.subject.x;
  d3.event.subject.fy = d3.event.subject.y;
  console.log(d3.event.subject);
}

function dragged() {
  d3.event.subject.fx = d3.event.x;
  d3.event.subject.fy = d3.event.y;
}

function dragended() {
  if (!d3.event.active) simulation.alphaTarget(0);
  d3.event.subject.fx = null;
  d3.event.subject.fy = null;
}



function drawNode(d) {
  ctx.beginPath();
  ctx.fillStyle = color(d.party);
  ctx.moveTo(d.x, d.y);
  ctx.arc(d.x, d.y, r, 0, Math.PI*2);
  ctx.fill();
}

function drawLink(l) {
  ctx.moveTo(l.source.x, l.source.y);
  ctx.lineTo(l.target.x, l.target.y);
}




</script>

</body>
</html>